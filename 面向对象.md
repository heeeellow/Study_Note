# CPP面向对象

---

## 一、访问修饰符
### 1. `public` (公共的)

被 `public` 修饰的成员可以被程序中的任何部分访问，无论是类的内部、派生类，还是类的外部。
* 访问权限：所有代码。
* 用途：定义类的公共接口 (Public Interface)。这些是类的使用者可以调用的函数和访问的数据，就像电视机的按钮和遥控器一样，是提供给用户操作的。

**示例代码：**

```cpp

#include <iostream>
#include <string>

class Dog {
public:
    // 公共成员变量 (通常不推荐，但此处为演示)
    std::string breed;

    // 公共成员函数 (推荐)
    void bark() {
        std::cout << "Woof! Woof!" << std::endl;
    }
};

int main() {
    Dog myDog;
    myDog.breed = "Golden Retriever"; // 从外部直接访问公共成员变量
    myDog.bark();                     // 从外部直接调用公共成员函数
    std::cout << "My dog is a " << myDog.breed << std::endl;
    return 0;
}
```

---

### 2. `private` (私有的)

被 `private` 修饰的成员是类中最私密的部分，访问权限最严格。
* 访问权限：只能是该类自己的成员函数。派生类和类的外部代码都无法访问。
* 用途： 隐藏类的实现细节和内部数据。这是封装的核心，也叫作“信息隐藏”。通过将数据设为私有，你可以强制外部代码通过你提供的公共接口（public 函数）来与之交互，从而确保数据的有效性和一致性。

**示例代码：**

```cpp

#include <iostream>
#include <string>

class Person {
public:
    // 公共接口，用于间接访问私有数据
    void setAge(int age) {
        if (age > 0 && age < 150) { // 在这里可以进行数据验证
            age_ = age;
        }
    }

    int getAge() const {
        return age_;
    }

private:
    // 私有成员变量，外部无法直接访问
    int age_;
    std::string social_security_number_; // 敏感信息
};

int main() {
    Person p;
    // p.age_ = 30; // 编译错误！'age_' is private
    
    p.setAge(30);  // 必须通过公共方法来设置年龄
    std::cout << "Person's age: " << p.getAge() << std::endl;
    return 0;
}
```
在这个例子中，`age_` 是私有的，你不能直接修改它。你必须调用 `setAge` 方法，这个方法可以加入逻辑来防止设置无效的年龄（比如负数）。这就是 `private` 的威力所在。

---

### 3. `protected` (受保护的)

`protected` 是介于`public` 和 `private` 之间的一种访问权限，它与继承 (Inheritance) 密切相关。
* 访问权限：该类自己的成员函数以及它的所有派生类（子类）。类的外部代码无法访问。
* 用途：允许基类向其子类开放部分实现细节，但同时对外部世界保持隐藏。这对于设计可扩展的类库非常有用。

**示例代码：**
```cpp

#include <iostream>
#include <string>

// 基类 (Base Class)
class Animal {
public:
    void eat() {
        std::cout << "This animal is eating." << std::endl;
    }
protected:
    // 受保护的成员，子类可以访问
    int energy_level_; 
};

// 派生类 (Derived Class)
class Cat : public Animal {
public:
    void meow_and_run() {
        std::cout << "Meow!" << std::endl;
        // 子类 Cat 可以访问基类 Animal 的 protected 成员
        energy_level_ -= 10; 
        std::cout << "Cat is running, energy level is now: " << energy_level_ << std::endl;
    }

    void setInitialEnergy(int energy) {
        energy_level_ = energy; // 子类可以修改
    }
};

int main() {
    Cat myCat;
    myCat.eat(); // 可以访问基类的 public 成员
    myCat.setInitialEnergy(100);
    myCat.meow_and_run();

    // myCat.energy_level_ = 50; // 编译错误！'energy_level_' is protected
    // 在类的外部，protected 成员和 private 成员一样，都是不可访问的。
    return 0;
}
```

### 常见使用方法：

* 默认使用 `private：`将所有成员变量都声明为 private。这是封装的基本原则。
* 提供` public `接口：通过 public 成员函数（通常称为 getters 和 setters）来提供对私有数据的受控访问。
* 谨慎使用 `protected：`protected 成员会破坏基类的封装性，因为所有子类都能随意修改它。在某些设计模式下它很有用，但先考虑是否可以通过 private 数据加上 protected 函数来达到同样的目的。

--- 

## 二、面向对象三大特性
### 1. 封装
* 封装是指把数据和操作方法包装到类（class）中，通过访问控制（public / protected / private）隐藏实现细节，只暴露稳定、受控的接口。
* 为什么需要封装？
    * 安全性 (Security)：保护内部数据不被外部随意篡改，保证了数据的完整性和有效性。例如，银行账户的余额不能被随意改成负数。
    * 简化复杂性 (Simplicity)：使用者无需关心复杂的内部实现，只需调用简单的接口即可。
    * 提高可维护性 (Maintainability)：当内部实现需要修改或优化时，只要公共接口不变，就不会影响到使用该对象的外部代码。
    
**示例：带不变量检查的账户类:**

```cpp
#include <stdexcept>
#include <string>

class BankAccount {
public:
    explicit BankAccount(std::string owner, double initial = 0.0)
        : owner_(std::move(owner)), balance_(initial) {
        if (initial < 0) throw std::invalid_argument("initial < 0");
    }

    void deposit(double amount) {
        if (amount <= 0) throw std::invalid_argument("amount <= 0");
        balance_ += amount;
    }

    void withdraw(double amount) {
        if (amount <= 0) throw std::invalid_argument("amount <= 0");
        if (balance_ < amount) throw std::runtime_error("insufficient");
        balance_ -= amount;
    }

    double balance() const noexcept { return balance_; }
    const std::string& owner() const noexcept { return owner_; }

private:
    std::string owner_;  // 细节隐藏
    double balance_;     // 不允许外部随便改
};
```

---

### 2. 继承
#### 2.1 什么是继承？

继承是面向对象编程的一个核心机制，它允许我们创建一个新类（派生类 / 子类，Derived / Child Class），这个新类可以获取一个已存在类（基类 / 父类，Base / Parent Class）的属性和方法。

这种关系通常被称为 “is-a” (是一种) 关系。例如，`Car`(小汽车) *is-a* `Vehicle` (交通工具)。

---

#### 2.2 为什么需要继承？
* 代码复用 (Code Reusability)：将多个类共有的属性和方法提取到基类中，避免重复编写，减少代码冗余。

* 建立层次结构 (Logical Hierarchy)：使代码的组织结构更贴近现实世界的分类关系，增强了代码的可读性和逻辑性。

* 实现多态 (Foundation for Polymorphism)：继承是实现多态的前提。没有继承，就无法实现“一个接口，多种形态”的动态行为。

* 可扩展性 (Extensibility)：可以方便地在不修改基类的情况下，通过派生新的子类来扩展功能。

---

#### 2.3 继承的三种方式

C++ 提供了三种继承方式：`public`,`protected`, 和 `private`。它们的核心区别在于：基类的成员在派生类中的访问权限会如何变化。

记住一个总原则：派生类永远无法访问基类的 private 成员。 继承方式控制的是基类的 public 和 protected 成员在派生类中的“能见度”。

##### 2.3.1 `public` 继承 (公有继承)

这是最常用、最直观的继承方式，它完美地体现了 “is-a” 的关系。
* 规则：
    * 基类的 `public` 成员在派生类中仍然是 public。
    * 基类的 `protected` 成员在派生类中仍然是 protected。
* 何时使用：当你希望明确表示 “派生类是一种基类” 时。这是实现多态的基础。

**示例代码：**
```cpp

    class Vehicle {
    public:
        void start() {}
    protected:
        int speed;
    };

    class Car : public Vehicle {
    public:
        void honk() {
            start();   // OK, 基类的 public 成员在派生类中是 public
            speed = 0; // OK, 基类的 protected 成员在派生类中是 protected
        }
    };

    int main() {
        Car myCar;
        myCar.start();   // OK, 因为 start() 在 Car 中是 public
        // myCar.speed = 10; // 编译错误! speed 在 Car 中是 protected，外部无法访问
    }
```

---

##### 2.3.2 `private` 继承 (私有继承)

它体现的是 “is-implemented-in-terms-of” (依据...来实现) 的关系，而不是 “is-a”。
* 规则：
    * 基类的 `public` 成员在派生类中变为 private。
    * 基类的 `protected` 成员在派生类中变为 private。
* 何时使用：当你想复用一个类的实现细节，但又不希望外部代码将派生类当作基类来使用时。这是一种实现上的技巧，而非概念上的分类。

**示例代码：**
```cpp

    class Timer {
    public:
        void start() {}
        void stop() {}
    protected:
        long long startTime;
    };

    // JobQueue 内部需要一个计时器，但 JobQueue “不是一个” Timer
    class JobQueue : private Timer {
    public:
        void processJobs() {
            start();          // OK, 基类的 public 成员在派生类中是 private
            startTime = 0;    // OK, 基类的 protected 成员在派生类中是 private
            // ... process jobs ...
            stop();
        }
    };

    int main() {
        JobQueue jq;
        jq.processJobs();
        // jq.start(); // 编译错误! start() 在 JobQueue 中是 private
    }

```

---

##### 2.3.3 `protected` 继承 (保护继承)

这种方式非常少见，其行为介于 `public` 和 `private` 之间。
* 规则：
    * 基类的 `public` 成员在派生类中变为 protected。
    * 基类的 `protected` 成员在派生类中仍然是 protected。
* 何时使用：当你希望派生类以及“派生类的派生类”能够访问基类接口，但同时又不想让外部代码访问时。

---

#### 2.4.继承中的关键问题

##### 2.4.1构造与析构调用顺序

* **构造 (Construction): 从基类到派生类 (Base -> Derived)**
    1. 分配内存：为整个对象（包括基类部分和派生类部分）分配内存。
  
    2. 调用基类构造函数：初始化对象的基类部分。

    3. 初始化派生类成员：按照在类中声明的顺序初始化派生类自己的成员变量。

    4. 执行派生类构造函数体：执行派生类构造函数 {} 中的代码。

* **析构 (Destruction): 从派生类到基类 (Derived -> Base)**

    1. 执行派生类析构函数体：执行派生类析构函数 {} 中的代码。

    2. 销毁派生类成员：按照声明的逆序销毁派生类自己的成员变量。

    3. 调用基类析构函数：销毁对象的基类部分。

    4. 释放内存。

* **追问：为什么是这个顺序？**

* 构造：派生类很可能需要依赖基类的数据或功能来完成自身的初始化。因此，必须保证在派生类构造开始之前，其“地基”（基类部分）已经完全构建好了。这是一种依赖关系。

* 析构：这同样是基于依赖关系。派生类可能会使用基类的资源。必须先安全地清理完派生类自身（解除对基类的依赖），然后才能安全地拆除“地基”（基类部分）。

---

##### 2.4.2基类构造函数的调用

* 默认行为：如果派生类的构造函数没有明确指定，编译器会尝试调用基类的默认构造函数（即无参构造函数）。

* 问题所在：

    * 如果基类没有默认构造函数（例如，只有一个需要参数的构造函数）。

    * 如果你需要用派生类构造函数接收的参数来初始化基类。

* 解决方案：成员初始化列表 (Member Initializer List)
    这是唯一向基类构造函数传递参数的方式。
    
**示例代码：**

```cpp
#include <iostream>
#include <string>

class Person {
public:
    // 基类没有默认构造函数
    Person(const std::string& name) : name_(name) {
        std::cout << "Person constructed with name: " << name_ << std::endl;
    }
    ~Person() {
        std::cout << "Person destructed." << std::endl;
    }
protected:
    std::string name_;
};

class Student : public Person {
public:
    // 错误：编译器找不到 Person::Person()
    // Student(int id) { /* ... */ } 

    // 正确：使用成员初始化列表将参数传递给基类构造函数
    Student(const std::string& name, int studentId)
        : Person(name), studentId_(studentId) { // 显式调用 Person(name)
        std::cout << "Student constructed with ID: " << studentId_ << std::endl;
    }
    ~Student() {
        std::cout << "Student destructed." << std::endl;
    }
private:
    int studentId_;
};

int main() {
    Student s("Alice", 12345);
}
/*
输出:
Person constructed with name: Alice
Student constructed with ID: 12345
Student destructed.
Person destructed.
*/
```

---

##### 2.4.3 虚析构函数 (Virtual Destructor)

为什么当一个类可能被用作基类时，其析构函数必须声明为 virtual？

 **问题根源：静态绑定 vs. 动态绑定**

当你通过一个基类指针指向一个派生类对象时：
`Base* ptr = new Derived();`

在 `delete ptr`; 时，编译器需要决定调用哪个析构函数。

* 如果 `~Base()` 不是 virtual：编译器会进行静态绑定 (Static Binding)。它只看指针的类型 (Base*)，而不管它实际指向什么。因此，它只会生成调用 ~Base() 的代码。

* 如果 `~Base() `是 virtual：编译器会进行动态绑定 (Dynamic Binding)。它会通过虚函数表 (vtable) 在运行时查找` ptr `实际指向的对象类型 (Derived)，并调用该类型的析构函数，即` ~Derived()`。

* **灾难性后果 (如果析构函数非虚)：**

    * 派生类的析构函数永远不会被调用。

    * 导致资源泄漏 (Resource Leak)。任何在 ~Derived() 中应该被释放的资源（如动态分配的内存、文件句柄、网络连接、线程锁等）都将永远丢失。

    * 程序的行为是未定义的 (Undefined Behavior, UB)，这是 C++ 中最危险的错误。

**“黄金法则”:**

法则：任何可能被用作多态基类的类，都必须有一个虚析构函数。 简单地说，如果你的类里有任何一个虚函数，就顺便把析构函数也声明为 virtual。

**示例代码：**

```cpp

#include <iostream>

class Base {
public:
    // 切换注释来看效果
    virtual ~Base() { std::cout << "Base destructor\n"; } // 正确
    // ~Base() { std::cout << "Base destructor\n"; }       // 错误
};

class Derived : public Base {
public:
    Derived() { p_ = new int[100]; std::cout << "Resource allocated\n"; }
    ~Derived() override { // C++11 override 关键字
        delete[] p_;
        std::cout << "Resource deallocated. Derived destructor\n";
    }
private:
    int* p_;
};

int main() {
    Base* ptr = new Derived();
    delete ptr; 
    // 如果 ~Base() 非虚, 输出将是:
    // Resource allocated
    // Base destructor
    // (内存泄漏发生!)

   // 如果 ~Base() 是虚函数, 输出将是:
    // Resource allocated
    // Resource deallocated. Derived destructor
    // Base destructor
    // (资源被正确释放)
}
```

---

##### 2.4.4名字隐藏 (Name Hiding)

当派生类中定义了一个与基类同名的成员函数时，无论参数列表是否相同，基类的所有同名函数（包括所有重载版本）在派生类的作用域中都会被隐藏。

* **追问：为什么会隐藏而不是重载？**

因为重载是发生在同一个作用域内的。而继承中，派生类创建了一个新的、嵌套的作用域。当编译器在派生类作用域中找到了一个匹配的名字后，它就会停止向外层（基类）作用域继续搜索。

* 代码陷阱
```cpp
class Machine {
public:
    void process() { /* ... */ }
    void process(int data) { /* ... */ }
};

class SuperComputer : public Machine {
public:
    void process() { /* A new, improved process... */ }
};

int main() {
    SuperComputer sc;
    sc.process();     // OK, 调用 SuperComputer::process()
    // sc.process(42); // 编译错误! Machine::process(int) 已被隐藏
}
```

* 解决方法

using 声明 (推荐)：在派生类中加入`using Base::function_name;` 可以将基类中所有被隐藏的同名函数“引入”到派生类的作用域中，使它们参与重载决议。
```cpp

class SuperComputer : public Machine {
public:
    using Machine::process; // 将 Machine 的所有 process 函数引入当前作用域
    void process() { /* ... */ }
};
// main 函数中 sc.process(42); 现在可以正常编译和调用了。
```

作用域解析运算符 "::"：通过显式指定作用域来调用基类版本。这是一种临时性的、非根本的解决方法。

```cpp
sc.Machine::process(42);
```

---

##### 2.4.5多重继承与菱形问题

* 多重继承：一个派生类可以同时继承自多个基类。`class C : public A, public B {};`

    * 优点：可以组合多个类的功能。

    * 缺点：可能导致命名冲突和著名的菱形问题。

* 菱形问题详解：当两个类（B 和 C）继承自同一个基类（A），而又有另一个类（D）同时继承自 B 和 C 时，就形成了一个菱形的继承结构。

* 结构图:
```
      A
     / \
    B   C
     \ /
      D
```
* 问题：D 中会包含两份来自 A 的成员数据，这会导致两个问题：

    * 数据冗余：浪费内存。

    * 二义性 (Ambiguity)：当通过 D 的对象访问 A 的成员时，编译器不知道该访问 B 路径下的 A 成员，还是 C 路径下的 A 成员。`d.a_member; // 编译错误: ambiguous`

* 解决方案：虚继承 (Virtual Inheritance)
    * 虚继承保证：无论有多少条路径继承同一个基类，最终派生类对象中只保留一份基类子对象。
    
    * 通过在 B 和 C 继承 A 时使用 virtual 关键字，编译器会把 A 的子对象“提升”到 D 中，B 和 C 只是保存一份“指向 A 子对象的指针/偏移量”（叫做“虚基类指针” vbptr）。这样，无论是 B 还是 C 访问 A::val，最终指向的都是同一份 A 子对象。
```cpp

class A { public: int data; };
class B : virtual public A {}; // 使用虚继承
class C : virtual public A {}; // 使用虚继承
class D : public B, public C {};

int main() {
    D d;
    d.data = 100; // OK, 不再有二义性，因为只有一份 data
}
```

---

### 3.多态（Polymorphism）

#### 3.1 多态是什么？

**多态（Polymorphism）**，字面意思是“多种形态”。C++面向对象编程中，多态让“同一个接口”可以对应“多种不同实现”，使用者只关心接口，而不关心具体实现细节。

* **意义**：最大化代码复用与扩展性。通过“面向基类编程”，在无需修改代码的情况下随时更换对象的“实际行为”。

C++里多态分为两种：

* **静态多态（编译期多态）**
* **动态多态（运行期多态）**

---

#### 3.2 动态多态（运行期多态）

##### 3.2.1 基本概念

* **实现方式**：基类中定义 `virtual` 虚函数，派生类重写（override），通过基类指针/引用访问对象时，根据实际对象类型在运行时自动分派到正确的函数实现。
* **本质**：运行期“动态绑定”（Dynamic Binding），靠虚函数表（vtable）+ 虚指针（vptr）实现。

##### 3.2.2 关键条件

1. 必须有**继承关系**（父子类）。
2. 基类函数必须声明为**virtual**。
3. 通过**基类指针或引用**调用虚函数。
4. 对象真实类型是派生类。
* **注意事项：**
    1. virtual仅能修饰类的非静态成员函数，全局函数、静态成员函数、友元函数不能被声明为虚函数。
    2. 虚函数的声明需在类内，定义可在类内或类外（类外定义时无需重复virtual关键字）。
##### 3.2.3 最小示例

```cpp
#include <iostream>
class Shape {
public:
    virtual void draw() { std::cout << "Drawing Shape\n"; }
    virtual ~Shape() = default; // 多态基类必须虚析构
};

class Circle : public Shape {
public:
    void draw() override { std::cout << "Drawing Circle\n"; }
};

void paint(Shape* s) { s->draw(); }

int main() {
    Circle c;
    paint(&c);  // 输出：Drawing Circle
}
```

##### 3.2.4 内部原理

* 每个含有虚函数的类，编译器都会生成一张**虚函数表**（vtable），表中存放本类所有虚函数的最终实现地址。

* 每个含有虚函数的类 都有自己的虚表，同一个类的所有对象共用同一张虚表（即静态表，不是每个对象都有一份）。

* 派生类会“继承”基类的虚表内容，如果重写了某个虚函数，会用派生类自己的函数覆盖基类的条目；如果新增虚函数，会追加到虚表末尾。

* 编译器会在含有虚函数的每个对象头部，自动加一个隐藏的指针成员（通常叫 **vptr**），它指向该对象所属类的虚表。

* 通过基类指针/引用调用虚函数时，实际会先通过vptr查表，再跳转到正确的函数实现。

##### 3.2.5 多态的好处

* **解耦接口与实现**：用户代码只关心接口（基类指针/引用），实现细节由派生类灵活扩展。
* **统一管理对象集合**：可以用 `std::vector<Shape*>` 管理不同派生类对象，统一处理，充分利用多态特性。
* **工厂模式、策略模式等OOP设计模式的基础**。

##### 3.2.6 必须使用虚析构函数！

**为什么？**

* 只有基类析构为virtual，`delete basePtr` 时才能自动先析构派生部分，再析构基类部分，避免资源泄露/UB。

```cpp
class Base {
public:
    virtual ~Base() { /* ... */ }
};
```

##### 3.2.7 多态细节与注意事项

* **只能调用基类接口**：基类指针/引用只能访问基类里声明的成员。如果派生类有额外接口，需要向下转型。
* **对象切片（Slicing）**：赋值或拷贝派生对象到基类对象，会丢失派生部分数据和虚函数多态能力。

  ```cpp
  Circle c;
  Shape s = c; // s只保留Shape部分，c的特性被“切片”掉
  ```
* **构造/析构期间的虚函数调用**：构造/析构时虚函数不会动态分派，只会调用当前类的实现。

##### 3.2.8 名字隐藏与重载

如果派生类声明了与基类同名的成员（不管参数表是否不同），基类所有同名成员都会被隐藏。要让基类的重载接口可见，需 `using Base::func;`。

---

#### 3.3 静态多态（编译期多态）

##### 3.3.1 定义

* 通过**模板**、**函数重载**、**运算符重载**、**CRTP（奇异递归模板模式）**等技术，让同一个接口在**编译期**选择不同实现，无需运行时分派，**零虚表开销**。

##### 3.3.2 典型用法

* 函数重载/运算符重载

```cpp
void print(int i) { std::cout << "int: " << i << std::endl; }
void print(double d) { std::cout << "double: " << d << std::endl; }
print(10);    // 选择 void print(int)
print(3.14);  // 选择 void print(double)
```

* 模板与泛型

```cpp
template<typename T>
void swap(T& a, T& b) {
    T temp = a; a = b; b = temp;
}
int x = 1, y = 2;
swap(x, y); // 实例化出 void swap(int&, int&)
double dx = 1.0, dy = 2.0;
swap(dx, dy); // 实例化出 void swap(double&, double&)
```

* CRTP（Curiously Recurring Template Pattern）

```cpp
template<typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->implementation();
    }
};

class Foo : public Base<Foo> {
public:
    void implementation() { std::cout << "Foo impl" << std::endl; }
};
```

*CRTP是编译期实现“像多态”行为的一种技巧，性能极高，但要求所有类型在编译期已知，缺乏运行时灵活性。*

##### 3.3.3 静态多态优缺点

* 优点：零虚表开销（无vptr/vtable）、支持内联、编译期决议、类型安全。
* 缺点：所有类型必须编译期已知、不支持运行时灵活扩展、可能导致代码膨胀（模板实例化多份代码）。

##### 3.3.4 应用场景

* 数学库、算法库、嵌入式开发、泛型容器等性能敏感场景。
* 大型系统中的策略切换（如果能编译期决定）。

---

#### 3.4 动态多态与静态多态的比较

| 特性   | 动态多态            | 静态多态          |
| ---- | --------------- | ------------- |
| 实现方式 | virtual 虚函数、继承  | 模板、重载、CRTP    |
| 决议时机 | 运行时（动态绑定）       | 编译期（静态绑定）     |
| 调用开销 | 有（虚表指针查找、不可内联）  | 无（可内联、零间接）    |
| 灵活性  | 高，支持运行时动态切换     | 低，类型固定，运行时不可变 |
| 扩展性  | 高，支持插件、面向接口编程   | 适中，所有类型需编译期确定 |
| 典型用途 | UI框架、游戏对象、插件系统等 | 算法库、容器、数值计算   |

---

#### 3.5多态常考点与陷阱

* **析构函数为何要 virtual？**

    * 保证通过基类指针删除派生对象时，能先析构派生部分再析构基类部分，否则会资源泄漏或UB。

* **为什么构造/析构期间虚函数不会多态？**

    * 构造期间对象还没成为派生类型，析构期间对象已经“退化”为基类，只能调用当前类的实现，防止依赖未初始化/已销毁的资源。

* **默认参数在虚函数里的绑定时机？**

    * **默认参数是静态绑定**，由指针/引用的静态类型决定，而不是动态分派。

* **如何避免对象切片？**

    * 用**指针/引用**操作多态对象，不要用值对象存储。例如 `std::vector<std::unique_ptr<Base>>`，不要用 `std::vector<Base>`。

* **C++11新特性：override/final**

    * `override`：写在派生类虚函数声明后，编译器强制检查“确实重写了基类虚函数”。
    * `final`：禁止进一步派生/重写，常用于稳定接口和优化。
    
---

* **多态中的默认参数陷阱**

以下程序输出结果是什么？

```cpp
class A {
public:
    virtual void func(int val = 1) { cout << "A->" << val << endl; }
    virtual void test() { func(); } // 隐含 this->func()
};

class B : public A {
public:
    void func(int val = 0) { cout << "B->" << val << endl; }
};

int main() {
    B* p = new B;
    p->test();
    return 0;
}
```

---

**考点拆解**

1. **虚函数的默认参数属于“静态绑定”**

* **默认参数是在“编译期”绑定到函数调用上的**，和函数的多态（动态绑定）是分开的。
* 谁来决定默认值？**取决于“声明该函数的指针/引用的静态类型”**。

2. **虚函数调用的两种分派**

* **函数体**：运行时根据对象实际类型来决定（多态/动态绑定）。
* **默认参数值**：编译时根据指针/引用的“声明类型”来决定（静态绑定）。

---

**代码执行过程分析**

1. `p` 的类型是 `B*`，但是 `test()` 是从基类 `A` 继承下来的。

2. `p->test()` 实际上调用的是 `A::test()`，等价于 `p->A::test()`。

3. `A::test()` 内容是 `func();`，注意这里没写参数，使用的是 `func(int val = 1)` 的默认参数。

4. 虚函数的动态绑定会让 `func()` 最终调用 `B::func`，但**参数值**的决定是在编译期根据 `A::func(int val = 1)` 得到 `val=1`。

5. 所以：

   * **动态绑定到 B::func**（所以实际输出 `B->`）
   * **参数仍然传 1**（因为 test() 定义时是按 A 的声明来的）

对应输出

```cpp
B->1
```

---


