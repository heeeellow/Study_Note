## 函数指针与指针函数

---


### 核心

  * **函数指针 (Function Pointer)**：**它是一个指针**。这个指针变量存放的是一个函数的内存地址。
  * **指针函数 (Pointer Function)**：**它是一个函数**。这个函数的返回值是一个指针（地址）。

-----

### 1. 函数指针 (Function Pointer)

#### 概念

函数指针的本质是一个**指针变量**，它不像普通的指针那样指向一个整型或字符型变量，而是指向一个**函数**。

我们知道，程序在编译后，每个函数都会在内存中占据一段空间，这段空间的首地址就是这个函数的地址。函数指针就是用来存储这个地址的。

它的最大作用是**实现了函数的动态调用**，也就是说，你可以在程序运行时根据不同的条件来决定具体调用哪一个函数。这为编写通用的、可扩展的代码提供了极大的便利。

#### 语法

函数指针的声明语法看起来有些复杂，关键在于括号：

```c
返回值类型 (*指针变量名)(参数列表);
```

**语法解析:**

  * `返回值类型`: 你要指向的那个函数的返回值类型。
  * `(*指针变量名)`: 这里的括号**至关重要**。`*` 表明这是一个指针，而括号将 `*` 和 `指针变量名` 捆绑在一起，表示“一个指向...的指针”。
  * `(参数列表)`: 你要指向的那个函数的参数类型和顺序。

**为什么括号是必须的？**
因为在 C/C++ 中，`()` 的优先级高于 `*`。

  * 如果没有括号，`int *p(int, int);`，编译器会将其解析为一个名为 `p` 的**函数**，该函数接收两个 `int` 参数，并返回一个 `int*` (整型指针)。这就是我们后面要讲的**指针函数**。
  * 有了括号，`int (*p)(int, int);`，`*p` 被首先结合，表明 `p` 是一个指针，然后外面的 `(int, int)` 表明它指向一个接收两个 `int` 参数的函数，最前面的 `int` 表明该函数返回一个 `int`。

#### 用法

我们来看一个完整的例子：

```c
#include <stdio.h>

// 准备两个函数，它们的签名（返回值和参数列表）完全相同
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    // 1. 声明一个函数指针
    // 它可以指向任何“返回值为int，接收两个int参数”的函数
    int (*pFunc)(int, int);

    // 2. 将函数地址赋值给函数指针
    pFunc = add; // 函数名本身就是函数的地址，所以不需要 & 符号
    // pFunc = &add; // 这样写也可以，效果相同

    // 3. 通过函数指针调用函数
    int result1 = (*pFunc)(10, 5); // 规范的、显式的调用方式
    printf("Calling via add: %d\n", result1); // 输出: Calling via add: 15

    // 4. 让函数指针指向另一个函数
    pFunc = subtract;

    // 5. 再次通过函数指针调用函数
    int result2 = pFunc(10, 5); // 这种是简化的、更常用的调用方式
    printf("Calling via subtract: %d\n", result2); // 输出: Calling via subtract: 5

    return 0;
}
```

#### 应用场景

1.  **回调函数 (Callback Function)**
    这是函数指针最经典、最广泛的用途。你编写一个通用函数（例如排序、遍历），但把其中某个具体的步骤（例如如何比较两个元素的大小）交由调用者通过传递一个函数指针来决定。

    最著名的例子就是 C 标准库中的 `qsort` 函数：

    ```c
    #include <stdio.h>
    #include <stdlib.h>

    // qsort需要一个比较函数，其指针作为参数传入
    // 这个函数决定了排序的规则（升序、降序等）
    int compare_int(const void* a, const void* b) {
        return (*(int*)a - *(int*)b); // 升序排序
    }

    int main() {
        int numbers[] = {5, 2, 8, 1, 9};
        int n = sizeof(numbers) / sizeof(numbers[0]);

        // 调用qsort，将我们的比较函数 compare_int 的地址传给它
        qsort(numbers, n, sizeof(int), compare_int);

        printf("Sorted array: ");
        for (int i = 0; i < n; i++) {
            printf("%d ", numbers[i]);
        }
        printf("\n"); // 输出: Sorted array: 1 2 5 8 9
        return 0;
    }
    ```

    在这里，`qsort` 并不知道如何比较 `int`，它只知道调用你传给它的那个函数（`compare_int`）来完成比较。

2.  **转移表 (Transfer Table)**
    当你有多个功能相似、函数签名相同的函数时，可以用一个函数指针数组来管理它们，根据索引或状态直接调用，这比使用冗长的 `if-else` 或 `switch-case` 结构更优雅、更高效。

    ```c
    // 接着上面的 add 和 subtract 函数
    void calculator(int a, int b, int op) {
        // 创建一个函数指针数组（转移表）
        int (*operations[])(int, int) = {add, subtract}; // 0: add, 1: subtract

        if (op >= 0 && op < 2) {
            int result = operations[op](a, b);
            printf("Result is: %d\n", result);
        } else {
            printf("Invalid operation.\n");
        }
    }

    int main() {
        calculator(20, 10, 0); // 输出: Result is: 30
        calculator(20, 10, 1); // 输出: Result is: 10
    }
    ```

-----

### 2. 指针函数 (Pointer Function)

#### 概念

指针函数的本质是一个**函数**，只不过它的**返回值类型是一个指针**。它和返回 `int`、`char` 或 `void` 的普通函数在本质上没有区别。

#### 语法

它的声明语法非常直观：

```c
返回值类型* 函数名(参数列表);
```

**语法解析:**

  * `返回值类型*`: 这里的 `*` 跟在类型后面，表示这个函数的返回值是一个指向 `返回值类型` 的指针。
  * `函数名`: 这就是一个普通的函数名。

#### 用法与注意事项

使用指针函数时，最需要注意的问题是：**函数返回的指针绝对不能指向函数内部的局部变量（栈变量）**。因为函数调用结束后，其栈帧会被销毁，局部变量的内存空间会被回收，返回的指针就变成了指向无效内存的“野指针”。

**错误的示例：**

```c
#include <stdio.h>

int* get_local_variable_address() {
    int local_var = 123;
    printf("Inside function: local_var address = %p\n", &local_var);
    return &local_var; // 严重错误！返回局部变量的地址
}

int main() {
    int* ptr = get_local_variable_address();
    printf("Outside function: pointer value = %p\n", ptr);
    
    // 下面的行为是未定义的！可能会崩溃，也可能输出垃圾值
    // 因为ptr指向的内存已经被释放了
    printf("Value pointed to: %d\n", *ptr); 
    
    return 0;
}
```

**正确的用法有三种：**

1.  **返回指向静态（`static`）变量的指针**：静态变量存储在静态存储区，其生命周期贯穿整个程序运行期间。

    ```c
    int* get_static_variable_address() {
        static int static_var = 456; // 静态变量，函数结束后不会被销毁
        return &static_var;
    }
    ```

2.  **返回指向堆（Heap）内存的指针**：在函数内动态分配内存（使用 `malloc` 或 `new`），返回其地址。调用者在使用完毕后，必须负责释放（`free` 或 `delete`）这块内存。

    ```c
    #include <stdlib.h> // for malloc

    int* allocate_memory() {
        int* ptr = (int*)malloc(sizeof(int));
        if (ptr != NULL) {
            *ptr = 789;
        }
        return ptr; // 返回堆内存地址
    }

    int main() {
        int* my_ptr = allocate_memory();
        if (my_ptr != NULL) {
            printf("Value from heap: %d\n", *my_ptr);
            free(my_ptr); // 调用者负责释放
            my_ptr = NULL;
        }
    }
    ```

3.  **返回传入的指针**：函数处理一个由调用者传入的指针，并将其原样或修改后返回。

---

### 总结与对比

| 特性 | 函数指针 (Function Pointer) | 指针函数 (Pointer Function) |
| :--- | :--- | :--- |
| **本质** | **一个指针变量** (A pointer) | **一个函数** (A function) |
| **定义语法** | `返回值 (*指针名)(参数);` | `返回值* 函数名(参数);` |
| **核心标志** | 指针名前的 `*` 被括号`()`包围 | 函数名前只有一个 `*`，且与返回值类型关联 |
| **用途** | 存储函数的地址，用于**间接调用函数**（如回调） | **返回一个地址**（指针），让调用者可以访问该地址处的数据 |

