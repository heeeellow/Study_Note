# 内存对齐

---

## 1. 什么是内存对齐

内存对齐（Memory Alignment）是指数据在内存中的存放位置。它并不是把数据随意地连续存放，而是让数据的起始地址“对齐”到一个特定的边界上，这个边界通常是该数据类型大小的整数倍。

**一个简单的比喻：**
想象一个图书馆的书架，每格宽度为8本书。

  * **对齐存放**：一本400页的厚书（占4个书位），图书管理员会把它放在第0、8、16...个位置，绝不会从第3个位置开始放，导致这本书跨越了两个格子。这样取书时，管理员一次就能把整本书拿出来。
  * **非对齐存放**：如果这本书从第6个位置开始放，它会占据6、7、8、9四个书位。管理员需要先从第一个格子取出书的后半部分，再从第二个格子取出书的前半部分，然后拼接起来，效率很低。

在计算机中，CPU 就是图书管理员，内存就是书架，数据就是书。CPU 访问内存通常不是一个字节一个字节地访问，而是以**字**为单位进行的块读取。一个字的大小通常是4字节（32位系统）或8字节（64位系统）。

---

## 2. 为什么要进行内存对齐

进行内存对齐主要有两个核心原因：

**1. 提升CPU访问性能**
这是最主要的原因。CPU 读取内存时，一次会读取一个字（比如4字节）。

  * **如果数据是对齐的**：一个4字节的 `int` 变量，其地址是4的倍数（如 `0x00000004`）。CPU 只需要**一次内存访问**就可以完整地读取这个 `int`。
  * **如果数据是未对齐的**：一个4字节的 `int` 变量，其地址不是4的倍数（如 `0x00000002`）。这个变量会跨越两个内存“字”。CPU 必须进行**两次内存访问**：第一次读取包含它前半部分的字，第二次读取包含它后半部分的字，然后再将两部分数据拼接起来，才能得到完整的 `int`。这会大大降低执行效率。

**2. 硬件平台要求**
某些硬件架构（如一些RISC架构的CPU，如ARM、MIPS）**不支持**未对齐的内存访问。如果尝试访问一个未对齐的数据，会直接触发硬件异常 (Hardware Exception)，导致程序崩溃。虽然x86/x64架构的CPU支持未对齐访问（以性能为代价），但为了代码的可移植性和高效性，遵循对齐规则是必须的。

此外，**原子操作 (Atomic Operations)** 通常也要求操作数是内存对齐的，以保证其原子性。

---

## 3. C/C++ 中的对齐规则

编译器会自动为你的数据进行内存对齐。你需要掌握其背后的规则，尤其是在处理结构体（`struct`）和联合体（`union`）时。

### a. 基本数据类型对齐

每个基本数据类型都有一个自身的**对齐系数 (alignment requirement)**。在没有特殊设置的情况下，这个值通常等于该类型的大小 `sizeof(type)`。

| 类型 | 大小 (典型64位系统) | 对齐系数 |
| :--- | :--- | :--- |
| `char` | 1 | 1 |
| `short` | 2 | 2 |
| `int` | 4 | 4 |
| `long` | 4 (Windows) / 8 (Linux) | 4 / 8 |
| `long long` | 8 | 8 |
| `float` | 4 | 4 |
| `double` | 8 | 8 |
| `pointer` | 8 | 8 |

### b. 结构体 (struct) / 类 (class) 的对齐规则

结构体的对齐遵循以下三条黄金法则：

1.  **成员对齐**：结构体的第一个成员，放在结构体起始位置的偏移量0处。之后每个成员的起始地址，必须是其**自身对齐系数**的整数倍。

      * `偏移量 % alignof(成员类型) == 0`

2.  **整体对齐**：结构体中所有成员都分配好空间后，结构体的**总大小**必须是其**有效对齐值**的整数倍。

      * `sizeof(struct) % 有效对齐值 == 0`

3.  **有效对齐值**：结构体的有效对齐值，取其所有成员中**最大的对齐系数**和**手动设置的对齐值（\#pragma pack(n)）中的较小者**。如果没有手动设置，则就是成员中最大的对齐系数。

      * `有效对齐值 = min(#pragma pack(n), max(alignof(成员1), alignof(成员2), ...))`

### 示例分析

让我们通过一个经典的例子来理解这些规则。

```c++
#include <iostream>

struct MyStruct {
    char a;     // 1 字节
    int b;      // 4 字节
    short c;    // 2 字节
};

int main() {
    std::cout << "sizeof(MyStruct) = " << sizeof(MyStruct) << std::endl;
    return 0;
}
```

**我们来手动计算 `sizeof(MyStruct)`：**

1.  **确定有效对齐值**：

      * `alignof(char)` 是 1。
      * `alignof(int)` 是 4。
      * `alignof(short)` 是 2。
      * 成员中最大的对齐系数是 4。没有 `#pragma pack` 设置，所以**有效对齐值是 4**。

2.  **分配成员空间 (遵循规则1)**：

      * `char a`：大小为1，对齐为1。放在偏移量 `0` 处。当前结构体大小为 `1`。
      * `int b`：大小为4，对齐为4。下一个可用偏移量是 `1`。`1 % 4 != 0`，不满足对齐要求。编译器需要填充(padding)字节，直到偏移量是4的倍数。
          * 填充3个字节（在偏移量1, 2, 3处）。
          * 现在偏移量为 `4`。`4 % 4 == 0`，满足要求。将 `b` 放在偏移量 `4` 处。
          * `b` 占据了 `4, 5, 6, 7` 四个字节。当前结构体大小为 `8`。
      * `short c`：大小为2，对齐为2。下一个可用偏移量是 `8`。`8 % 2 == 0`，满足要求。将 `c` 放在偏移量 `8` 处。
          * `c` 占据了 `8, 9` 两个字节。当前结构体大小为 `10`。

3.  **最终大小调整 (遵循规则2)**：

      * 所有成员分配完毕，当前总大小为 `10` 字节。
      * 结构体的有效对齐值是 `4`。
      * `10 % 4 != 0`，不满足整体对齐要求。编译器需要在末尾填充字节，直到总大小是 `4` 的倍数。
      * `10` 之后 `4` 的下一个倍数是 `12`。所以需要填充 `2` 个字节。
      * 最终结构体大小为 `12` 字节。

**内存布局可视化：**
`a` (1) | `pad` (1) | `pad` (1) | `pad` (1) | `b` (4) | `b` (4) | `b` (4) | `b` (4) | `c` (2) | `c` (2) | `pad` (1) | `pad` (1)
`[a]` `[x]` `[x]` `[x]` `[ b ]` `[ b ]` `[ b ]` `[ b ]` `[ c ]` `[ c ]` `[x]` `[x]`
Offset: 0   1   2   3    4    5    6    7    8    9   10  11

**所以，`sizeof(MyStruct)` 的结果是 12。**

**技巧：** 调整结构体成员顺序可以节省内存。如果把 `MyStruct` 改成：

```c++
struct MyStructOptimized {
    int b;      // 4 字节
    short c;    // 2 字节
    char a;     // 1 字节
};
```

计算过程：

1.  `int b`: 放在偏移量 `0`。当前大小 `4`。
2.  `short c`: 放在偏移量 `4` (4%2==0)。当前大小 `6`。
3.  `char a`: 放在偏移量 `6` (6%1==0)。当前大小 `7`。
4.  有效对齐值仍为4。当前大小 `7` 不是 `4` 的倍数，填充1字节。
5.  最终大小为 `8` 字节！

通过将对齐要求高的成员放在前面，可以有效减少因对齐产生的内存碎片，这是一个常见的优化技巧。

---

## 4. 如何控制内存对齐

有时我们需要手动控制对齐方式，比如在处理网络协议、文件格式或与特定硬件交互时。

**使用`#pragma pack(n)`**：

这是C/C++中一种编译器指令，用于设定**最大对齐字节数**。`n` 通常是 1, 2, 4, 8, 16。

  * 当使用 `#pragma pack(n)` 时，前面提到的**有效对齐值**计算规则变为：
    `有效对齐值 = min(n, 成员最大对齐系数)`

**示例：**

```c++
#pragma pack(push, 1) // 设置最大对齐为1字节，并保存当前设置
struct PackedStruct {
    char a;   // 1
    int b;    // 4
    short c;  // 2
};
#pragma pack(pop) // 恢复之前的对齐设置

// sizeof(PackedStruct) 将会是 1 + 4 + 2 = 7
```

`#pragma pack(1)` 意味着所有成员都按1字节对齐，取消了所有的对齐填充，结构体成员紧密排列。这在需要精确控制内存布局时非常有用，但会牺牲性能。

**注意：**

  * `#pragma pack` 是编译器相关的，虽然主流编译器都支持，但不是C++标准的一部分。
  * 使用 `push` 和 `pop` 是一个好习惯，可以避免影响到其他代码的对齐设置。

---
