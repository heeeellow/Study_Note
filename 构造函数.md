## 构造函数

---

### 1. 构造函数的基本概念

构造函数（Constructor）是一种特殊的成员函数，它在创建一个类（class）的对象时被自动调用。它的主要职责是**初始化对象的数据成员**，确保对象在创建后处于一个有效的、可用的状态。

**核心特点：**

  * 函数名与类名完全相同。
  * 没有返回类型，连 `void` 也没有。
  * 可以有参数，也可以没有参数。
  * 可以重载（Overload），即一个类可以有多个构造函数。
  * 不能被声明为 `const`、`volatile` 或 `static`，也不能是`virtual`。

-----

### 2. 构造函数的类型

#### a. 默认构造函数 (Default Constructor)

不接受任何参数的构造函数。

  * **编译器合成的默认构造函数**：如果你没有为类定义任何构造函数，编译器会自动为你生成一个无参的、公开的（public）默认构造函数。这个构造函数什么也不做（对于内置类型成员不会初始化，对于类类型成员会调用其默认构造函数）。
  * **用户定义的默认构造函数**：你可以自己定义一个。一旦你定义了任何一个构造函数（无论带不带参数），编译器就不再为你合成默认构造函数了。

**用法：**

```cpp
class Box {
public:
    double length;
    double width;

    // 用户定义的默认构造函数
    Box() {
        length = 1.0;
        width = 1.0;
        std::cout << "Default constructor called." << std::endl;
    }
};

// 如何调用
Box b1; // 调用默认构造函数
Box* b2 = new Box(); // 调用默认构造函数
```

**注意**：如果一个类有其他构造函数但没有默认构造函数，那么 `Box b1;` 这样的代码会编译失败。

---

#### b. 带参数构造函数 (Parameterized Constructor)

接受一个或多个参数，用于根据传入的参数来初始化对象。

**用法：**

```cpp
class Box {
public:
    double length;
    double width;

    // 带参数构造函数
    Box(double l, double w) {
        length = l;
        width = w;
        std::cout << "Parameterized constructor called." << std::endl;
    }
};

// 如何调用
Box b1(10.0, 5.0); // 调用带参数构造函数
```

---

#### c. 拷贝构造函数 (Copy Constructor)

用一个已存在的对象来创建一个新的、完全相同的对象。

它的参数通常是一个**对同类对象的常引用** (`const ClassName& other`)。

**用法与语法：**

```cpp
class Box {
public:
    double length;
    double width;

    Box(double l = 1.0, double w = 1.0) : length(l), width(w) {} // 带默认值的参数化构造函数

    // 拷贝构造函数
    Box(const Box& other) {
        length = other.length;
        width = other.width;
        std::cout << "Copy constructor called." << std::endl;
    }
};

// 如何调用
Box b1(10.0, 5.0);
Box b2 = b1;      // 调用拷贝构造函数 (情况1)
Box b3(b1);       // 调用拷贝构造函数 (情况2)
```

**注意**：

  * **为什么参数是引用？** 如果不是引用，传参时会发生值传递，这又会调用拷贝构造函数，从而导致无限递归。
  * **为什么是 `const` 引用？** 为了防止在拷贝过程中意外修改原始对象，并且能够接受一个常量对象作为参数。

---

#### d. 移动构造函数 (Move Constructor, C++11)

用于将一个对象的资源（如动态分配的内存、文件句柄等）“转移”或“窃取”给另一个对象，而不是复制它们。这通常发生在源对象即将被销毁的情况下（例如，临时对象）。这极大地提高了性能，避免了不必要的深拷贝。

它的参数是一个**对同类对象的右值引用** (`ClassName&& other`)。

**用法与语法：**

```cpp
#include <utility> // for std::move

class ResourceManager {
public:
    int* data;
    // ... 其他构造函数 ...

    // 移动构造函数
    ResourceManager(ResourceManager&& other) noexcept { // noexcept很重要
        data = other.data;    // 1. 窃取资源
        other.data = nullptr; // 2. 将源对象置于有效但“空”的状态
        std::cout << "Move constructor called." << std::endl;
    }
};

ResourceManager createResource() {
    return ResourceManager(); // 返回一个临时对象 (右值)
}

int main() {
    ResourceManager res1 = createResource(); // 返回的临时对象会触发移动构造函数
    ResourceManager res2 = std::move(res1);  // 显式将左值转为右值，触发移动
}
```

---

#### e. 转换构造函数 (Conversion Constructor)

可以只用一个参数调用的构造函数（非拷贝/移动构造函数）。这种构造函数定义了从参数类型到类类型的隐式转换规则。

**用法：**

```cpp
class MyNumber {
public:
    int value;
    // 转换构造函数: 可以将一个int隐式转换为MyNumber
    MyNumber(int v) : value(v) {
        std::cout << "Conversion constructor called." << std::endl;
    }
};

void printNumber(MyNumber num) {
    std::cout << num.value << std::endl;
}

int main() {
    MyNumber n = 10; // 隐式转换: int(10) -> MyNumber对象
    printNumber(20); // 隐式转换: int(20) -> MyNumber临时对象
}
```

**`explicit` 关键字**
为了防止不期望的隐式转换，可以在构造函数前加上 `explicit` 关键字。

```cpp
class MyNumber {
public:
    explicit MyNumber(int v) : value(v) {}
};

int main() {
    // MyNumber n = 10; // 编译错误！不能再隐式转换
    MyNumber n(10);    // 正确，必须显式调用
    // printNumber(20); // 编译错误！
    printNumber(MyNumber(20)); // 正确，显式创建临时对象
}
```

---

#### f. 委托构造函数 (Delegating Constructor, C++11)

允许一个构造函数调用同一个类中的另一个构造函数，从而简化代码，避免重复。

**用法：**

```cpp
class Box {
public:
    double length, width, height;

    // 目标构造函数
    Box(double l, double w, double h) : length(l), width(w), height(h) {}

    // 委托构造函数
    Box() : Box(1.0, 1.0, 1.0) {} // 委托给上面的构造函数

    // 委托构造函数
    Box(double side) : Box(side, side, side) {}
};
```

---

### 3. 初始化列表 (Initialization List)

在构造函数名和函数体 `{}` 之间，以冒号 `:` 开始，后面跟着一系列成员变量及其初始值的列表。

**语法：**
`ClassName(args) : member1(value1), member2(value2), ... {}`

#### a.与在构造函数体内赋值的区别（**核心**）

  * **初始化列表**：执行的是**初始化 (Initialization)**。成员变量在进入构造函数体之前就已经被创建并完成了初始化。
  * **函数体内赋值**：执行的是**赋值 (Assignment)**。成员变量会先经过一个默认的初始化过程，然后在函数体内被赋予新值。

**举例说明：**

```cpp
class Member {
public:
    Member() { std::cout << "Member default constructor\n"; }
    Member(const Member&) { std::cout << "Member copy constructor\n"; }
    Member& operator=(const Member&) { std::cout << "Member assignment operator\n"; return *this; }
};

class MyClass {
public:
    Member m;

    // 使用初始化列表
    MyClass() : m() { // m在这里被默认初始化
        std::cout << "MyClass constructor body\n";
    }

    /*
    // 使用函数体内赋值
    MyClass() {
        // 在这行代码之前，m已经被默认初始化了！
        Member temp;
        m = temp; // 这里调用的是赋值操作符=
        std::cout << "MyClass constructor body\n";
    }
    */
};
```

对于初始化列表，`m` 只调用了一次默认构造函数。
对于函数体内赋值，`m` 会先调用一次默认构造函数，然后在函数体内再调用一次赋值操作符，效率较低。

**结论：** 应该**优先使用初始化列表**，因为它更高效，并且是真正的“初始化”。

#### b.必须使用初始化列表的场景

有些情况下，**必须**使用初始化列表，因为赋值操作行不通：

1.  **初始化 `const` 成员变量**：`const` 变量必须在定义时初始化，之后不能被赋值。
2.  **初始化引用成员变量 (`&`)**：引用必须在定义时绑定到一个对象，之后不能再引用其他对象。
3.  **初始化没有默认构造函数的类成员**：如果一个成员是另一个类的对象，而那个类没有默认构造函数，你必须在初始化列表中明确调用它的某个构造函数。
4.  **初始化基类 (Base Class)**：当派生类构造时，需要调用基类的构造函数。这必须在初始化列表中完成。

**示例代码：**

```cpp
class Base {
public:
    Base(int i) {} // 没有默认构造函数
};

class Derived : public Base {
public:
    const int c_val;
    int& r_val;
    int some_val;

    Derived(int& ref) :
        Base(10),       // 4. 必须初始化基类
        c_val(100),     // 1. 必须初始化const成员
        r_val(ref),     // 2. 必须初始化引用成员
        some_val(0)
    {
        // c_val = 100; // 错误！不能给const成员赋值
        // r_val = ref; // 错误！引用必须在创建时绑定
    }
};
```

---

### 4. 深拷贝 vs 浅拷贝 (Deep Copy vs Shallow Copy)

这个概念主要与包含**指针**和**动态分配资源**的类相关，通常在**拷贝构造函数**和**拷贝赋值运算符**中体现。

#### a. 浅拷贝 (Shallow Copy)

  * **行为**：简单地复制成员变量的值。如果成员是一个指针，那么只复制指针的地址，而不是指针指向的内容。
  * **问题**：这会导致两个对象的指针指向同一块内存地址。
  * **风险**：
    1.  **悬挂指针 (Dangling Pointer)**：如果一个对象被销毁，它会释放那块内存。此时，另一个对象的指针就变成了指向无效内存的悬挂指针。
    2.  **二次释放 (Double Free)**：当第二个对象也被销毁时，它会尝试再次释放已经被释放的内存，导致程序崩溃。

#### b. 深拷贝 (Deep Copy)

  * **行为**：在拷贝指针成员时，不仅仅是复制地址，而是为新对象**重新分配一块内存**，然后将原始对象指针所指向的内容复制到这块新内存中。
  * **结果**：两个对象各自拥有独立的内存资源，互不影响。

#### 综合示例：实现一个自定义的 `MyString` 类

```cpp
#include <iostream>
#include <cstring> // for strlen, strcpy

class MyString {
private:
    char* m_data;
    size_t m_len;

public:
    // 默认构造函数
    MyString() : m_data(new char[1]{'\0'}), m_len(0) {
        std::cout << "Default constructor\n";
    }

    // 带参数构造函数
    MyString(const char* p) {
        std::cout << "Parameterized constructor\n";
        m_len = strlen(p);
        m_data = new char[m_len + 1];
        strcpy(m_data, p);
    }

    // 析构函数: 释放动态分配的内存
    ~MyString() {
        std::cout << "Destructor for: " << (m_data ? m_data : "nullptr") << std::endl;
        delete[] m_data;
    }

    // 拷贝构造函数 (深拷贝实现)
    MyString(const MyString& other) {
        std::cout << "Copy constructor (DEEP COPY)\n";
        m_len = other.m_len;
        // 为新对象分配自己的内存
        m_data = new char[m_len + 1];
        // 复制内容，而不是地址
        strcpy(m_data, other.m_data);
    }

    // 拷贝赋值运算符 (深拷贝实现)
    MyString& operator=(const MyString& other) {
        std::cout << "Copy assignment operator (DEEP COPY)\n";
        if (this == &other) { // 1. 检查自赋值
            return *this;
        }
        delete[] m_data; // 2. 释放旧资源

        m_len = other.m_len;
        m_data = new char[m_len + 1]; // 3. 分配新资源
        strcpy(m_data, other.m_data); // 4. 拷贝内容

        return *this;
    }

    void print() const {
        std::cout << m_data << std::endl;
    }
};

int main() {
    MyString s1("hello"); // 带参数构造
    MyString s2 = s1;     // 拷贝构造 (深拷贝)

    std::cout << "s1: "; s1.print();
    std::cout << "s2: "; s2.print();

    MyString s3; // 默认构造
    s3 = s1;     // 拷贝赋值

    std::cout << "s3: "; s3.print();
    return 0;
}
// 程序结束时，s1, s2, s3的析构函数会被调用，因为是深拷贝，各自释放自己的内存，不会出错。
// 如果是浅拷贝，这里会发生double free。
```

-----

### 5. "三/五法则" (The Rule of Three/Five)

这是一个C++编程的经验法则：

  * **三法则 (The Rule of Three)**：如果你需要显式地定义**析构函数**、**拷贝构造函数**或**拷贝赋值运算符**中的任何一个，那么你可能需要把这三个都定义。因为需要自己管理资源（如`MyString`中的`m_data`）的类，通常在这三个地方都需要特殊的逻辑。

  * **五法则 (The Rule of Five, C++11)**：随着C++11引入了移动语义，三法则扩展为五法则。如果你定义了上述三个函数中的任何一个，那么你可能需要定义所有五个：

    1.  析构函数
    2.  拷贝构造函数
    3.  拷贝赋值运算符
    4.  **移动构造函数**
    5.  **移动赋值运算符**

    这确保了类既能被安全地复制，也能被高效地移动。

---

### 6. 快问快答

1.  **构造函数是什么？** 自动调用的、用于初始化对象的特殊成员函数。
2.  **构造函数有哪几种？** 默认、带参、拷贝、移动。能说出委托和转换构造函数是加分项。
3.  **初始化列表和函数体内赋值的区别？** 初始化 vs 赋值。前者更高效，是真正的初始化。
4.  **什么时候必须用初始化列表？** 初始化 `const` 成员、引用成员、没有默认构造函数的成员、基类。
5.  **深拷贝和浅拷贝的区别？** 关键在于如何处理指针成员。浅拷贝只复制指针地址，导致资源共享和二次释放问题；深拷贝为新对象分配独立资源并复制内容。
6.  **什么时候需要实现深拷贝？** 当类中含有指针或句柄等指向外部资源的成员时。
7.  **什么是“五法则”？** 如果你自定义了析构、拷贝构造、拷贝赋值、移动构造、移动赋值中的任何一个，那么最好将它们全部实现，以保证资源管理的正确性和完整性。
8.  **`explicit` 关键字的作用？** 放在单参数构造函数前，防止不必要的隐式类型转换。

---

