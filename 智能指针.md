# 智能指针

---

## 1. 为什么需要智能指针？

在传统的C/C++编程中，我们使用 `new` 在堆上分配内存，并用 `delete` 来手动释放。这个过程充满了风险：

  * **忘记 `delete`**：导致**内存泄漏 (Memory Leak)**。程序占用的内存越来越多，最终可能耗尽资源而崩溃。
  * **重复 `delete`**：对同一块内存释放两次，会导致未定义行为，通常是程序崩溃。
  * **野指针 (Dangling Pointer)**：指针指向的内存已经被释放，但指针本身没有被置空，后续对该指针的访问会导致灾难性后果。

**核心问题**：手动管理内存，开发者需要精确地知道谁（哪个指针）拥有这块内存，以及何时应该释放它。在复杂的程序中（例如，函数有多个返回路径、发生异常等），这变得极其困难。

**智能指针的解决方案**：将内存（或任何资源）的所有权封装在一个对象中。当这个对象离开作用域时，它的析构函数会自动被调用，并在析构函数中释放所管理的资源。这就是自动化内存管理。

---

## 2. RAII机制：智能指针的基石

**RAII (Resource Acquisition Is Initialization)**，翻译为“资源获取即初始化”，是C++语言的核心思想之一。

  * **核心理念**：将资源的生命周期与一个对象的生命周期绑定。
  * **实现方式**：
      * 在对象的**构造函数**中获取资源（例如，`new` 分配内存）。
      * 在对象的**析构函数**中释放资源（例如，`delete` 释放内存）。
  * **优势**：C++保证了当一个栈上对象离开其作用域时，其析构函数一定会被调用（即使发生了异常）。这确保了资源总能被正确释放。

**所有的智能指针都是RAII机制的完美实践。**

-----

## 3. `std::unique_ptr`：独占所有权的指针

`std::unique_ptr` 是最简单、最高效的智能指针。正如其名，它对所管理的对象拥有**独占所有权**。

### 概念与特性

  * **独占性**：在任何时刻，只有一个 `unique_ptr` 可以指向一个给定的对象。
  * **轻量级**：它的开销和原始指针几乎完全一样，没有额外的性能负担。
  * **不可复制**：你不能复制一个 `unique_ptr`，因为它会破坏所有权的唯一性。
    ```cpp
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    // std::unique_ptr<int> ptr2 = ptr1; // 编译错误！
    ```
  * **可以移动**：虽然不能复制，但可以通过**移动语义 (Move Semantics)** 将所有权从一个 `unique_ptr` **转移**给另一个。
    ```cpp
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    std::unique_ptr<int> ptr2 = std::move(ptr1); // 正确，ptr1现在为空，ptr2拥有所有权
    ```

### 具体用法

**创建 `unique_ptr` (推荐方式)**
使用 `std::make_unique` (C++14及以上)，这是最安全、最高效的方式。

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "MyClass constructed.\n"; }
    ~MyClass() { std::cout << "MyClass destructed.\n"; }
    void greet() { std::cout << "Hello from MyClass!\n"; }
};

void foo() {
    // 使用 make_unique 创建 unique_ptr
    std::unique_ptr<MyClass> u_ptr = std::make_unique<MyClass>();
    u_ptr->greet();
    // 当 foo 函数结束时，u_ptr 会离开作用域，其析构函数被调用
    // 析构函数会自动 delete 所管理的对象，MyClass 的析构函数被调用
}

int main() {
    std::cout << "Entering main.\n";
    foo();
    std::cout << "Exiting main.\n";
    return 0;
}
// 输出：
// Entering main.
// MyClass constructed.
// Hello from MyClass!
// MyClass destructed.
// Exiting main.
```

**所有权转移**
常用于函数返回值或参数传递。

```cpp
// 工厂函数，创建并返回一个对象的所有权
std::unique_ptr<MyClass> createMyClass() {
    return std::make_unique<MyClass>();
}

// 函数接收一个对象的所有权
void takeOwnership(std::unique_ptr<MyClass> ptr) {
    std::cout << "takeOwnership function now owns the object.\n";
    ptr->greet();
}

int main() {
    std::unique_ptr<MyClass> my_obj = createMyClass();
    takeOwnership(std::move(my_obj)); // 显式移动所有权
    
    // 此时 my_obj 已经是 nullptr
    if (!my_obj) {
        std::cout << "my_obj is now empty.\n";
    }
}
```

**要点**：

  * **默认首选**：当你需要一个智能指针时，`unique_ptr` 应该是你的第一选择。只有当你确定需要共享所有权时，才考虑 `shared_ptr`。
  * **零开销抽象**：它体现了C++的“零开销抽象”原则。

---

## 4. `std::shared_ptr`：共享所有权的指针

`std::shared_ptr` 允许多个指针共同拥有同一个对象。

### 概念与特性

  * **共享所有权**：可以被自由地复制和赋值，多个 `shared_ptr` 可以指向同一个对象。
  * **引用计数 (Reference Counting)**：`shared_ptr` 内部维护一个“引用计数”，记录有多少个 `shared_ptr` 实例正指向同一个对象。
      * 每当一个新的 `shared_ptr` 指向该对象时（例如通过复制），引用计数加1。
      * 每当一个 `shared_ptr` 被销毁或指向其他对象时，引用计数减1。
      * 当引用计数变为0时，代表没有任何 `shared_ptr` 指向该对象，对象会被自动删除。
  * **控制块 (Control Block)**：引用计数等管理信息存储在一个单独的“控制块”中，这个控制块是在第一个 `shared_ptr` 创建时动态分配的。

### 具体用法

**创建 `shared_ptr` (推荐方式)**
同样，使用 `std::make_shared` (C++11及以上) 是最佳选择。它比 `std::shared_ptr<T>(new T())` 更好，因为它只进行一次内存分配（同时为对象和控制块分配），而后者需要两次。

```cpp
#include <iostream>
#include <memory>
#include <vector>

void use_shared_ptr() {
    // 使用 make_shared 创建
    std::shared_ptr<MyClass> s_ptr1 = std::make_shared<MyClass>();
    std::cout << "Use count: " << s_ptr1.use_count() << std::endl; // 输出 1

    {
        std::shared_ptr<MyClass> s_ptr2 = s_ptr1; // 复制，引用计数增加
        std::cout << "Use count: " << s_ptr1.use_count() << std::endl; // 输出 2
        s_ptr2->greet();
        // s_ptr2 在这里离开作用域，引用计数减少
    }

    std::cout << "Use count: " << s_ptr1.use_count() << std::endl; // 输出 1
    // use_shared_ptr 函数结束，s_ptr1 离开作用域，引用计数变为 0，对象被销毁
}
```

**要点**：

  * **性能开销**：相比 `unique_ptr`，`shared_ptr` 更大（通常是原始指针大小的两倍，一个指向对象，一个指向控制块），并且引用计数的增减是原子操作，有一定的线程安全开销。
  * **循环引用问题**：这是 `shared_ptr` 的致命弱点。如果两个对象通过 `shared_ptr` 相互引用，它们的引用计数永远不会变为0，从而导致内存泄漏。

---

## 5. `std::weak_ptr`：`shared_ptr`的“观察者”

`std::weak_ptr` 是为解决 `shared_ptr` 的循环引用问题而生的。

### 概念与特性

  * **非拥有型指针**：`weak_ptr` 指向一个由 `shared_ptr` 管理的对象，但它**不增加**引用计数。它仅仅是一个“观察者”。
  * **不能直接访问对象**：你不能通过 `weak_ptr` 直接调用 `->` 或 `*`。
  * **需要提升 (lock)**：要访问 `weak_ptr` 指向的对象，必须先调用 `lock()` 方法。
      * 如果对象仍然存在，`lock()` 会返回一个指向该对象的有效的 `shared_ptr`，并增加引用计数。
      * 如果对象已经被销毁，`lock()` 会返回一个空的 `shared_ptr`。
  * **检查是否过期**：可以使用 `expired()` 方法检查所指向的对象是否已被销毁。

### 具体用法：打破循环引用

经典的例子是树状结构中父节点指向子节点，子节点也想指回父节点。

```cpp
struct Node {
    ~Node() { std::cout << "Node destructed\n"; }
    // std::shared_ptr<Node> parent; // 错误的方式，会导致循环引用
    std::weak_ptr<Node> parent; // 正确的方式
    std::vector<std::shared_ptr<Node>> children;
};

void circular_reference_demo() {
    auto parent = std::make_shared<Node>();
    auto child = std::make_shared<Node>();

    parent->children.push_back(child);
    child->parent = parent; // child 指向 parent

    std::cout << "Parent use count: " << parent.use_count() << std::endl; // 输出 1
    std::cout << "Child use count: " << child.use_count() << std::endl; // 输出 2

    // 如果 child->parent 是 shared_ptr，这里 parent 和 child 的引用计数都大于0
    // 当函数结束时，它们的引用计数都无法降到0，导致内存泄漏。
    
    // 使用 weak_ptr 后，child->parent 不增加 parent 的引用计数。
    // 函数结束时，parent 的引用计数变为0，被销毁。
    // parent 销毁时，其 children vector 也被销毁，从而使 child 的引用计数变为0，child 也被销毁。
}
```

**要点**：

  * `weak_ptr` 的核心目的就是**打破循环引用**。
  * 一定要记住使用 `lock()` 来安全地访问其指向的对象。

---

## 6. 横向对比

| 特性 | `std::unique_ptr` | `std::shared_ptr` | `std::weak_ptr` |
| :--- | :--- | :--- | :--- |
| **所有权** | 独占 (Exclusive) | 共享 (Shared) | 非拥有 (Non-owning) |
| **引用计数** | 无 | 有 (原子操作) | 无 (观察shared\_ptr的) |
| **性能开销** | 极低 (等同于裸指针) | 较高 (大小、控制块、原子操作) | 较高 (需要访问控制块) |
| **可否复制** | 否 (只能移动) | 是 | 是 |
| **核心用途** | 对象所有权的唯一管理者 | 多处代码共享对象所有权 | 打破 `shared_ptr` 的循环引用 |
| **创建方式** | `std::make_unique` | `std::make_shared` | 从 `shared_ptr` 构造 |

**选择策略**：

1.  **默认使用 `std::unique_ptr`**。这是最安全、最高效的选择。
2.  当你确定需要共享对象的所有权时（例如，一个对象被多个数据结构同时引用），才使用 `std::shared_ptr`。
3.  当你发现 `shared_ptr` 之间可能形成循环引用时，将其中一个引用关系（通常是“子”指向“父”）改为 `std::weak_ptr`。

---

## 7. 快问快答

1.  **`std::make_shared` (或 `make_unique`) 相对于 `new` 的优势是什么？**

      * **异常安全**：考虑 `foo(std::shared_ptr<T>(new T()), some_func())`，如果 `some_func()` 抛出异常，`new T()` 分配的内存可能会泄漏。而 `std::make_shared<T>()` 能保证资源被正确管理。
      * **性能** (`make_shared`): `make_shared` 只进行一次内存分配（为对象和控制块），而 `std::shared_ptr<T>(new T())` 需要两次分配，一次为 `T`，一次为控制块。一次分配通常更快且能减少内存碎片。

2.  **`shared_ptr` 是线程安全的吗？**

      * **控制块是线程安全的**：多个线程可以同时复制、销毁指向同一个对象的 `shared_ptr` 实例，引用计数的增减是原子的，不会导致数据竞争。
      * **所管理的对象不是线程安全的**：如果多个线程通过各自的 `shared_ptr` 实例去修改对象本身的数据成员，你仍然需要自己加锁（如 `std::mutex`）来保护对象。

3.  **如何将 `this` 指针安全地传递给一个接受 `shared_ptr` 的函数？**

      * **错误做法**：`some_func(std::shared_ptr<MyClass>(this))`。这会创建一个新的、独立的 `shared_ptr`，它和外部已存在的 `shared_ptr` 拥有不同的控制块。当其中一个 `shared_ptr` 销毁对象后，另一个就会成为野指针，导致双重释放。
      * **正确做法**：让你的类继承自 `std::enable_shared_from_this<YourClass>`，然后调用 `shared_from_this()` 方法。这个方法会返回一个与已存在的 `shared_ptr` 共享所有权的新的 `shared_ptr`。

---

