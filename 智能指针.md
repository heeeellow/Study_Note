# 智能指针

---

## 1. 为什么需要智能指针？

在传统的C/C++编程中，我们使用 `new` 在堆上分配内存，并用 `delete` 来手动释放。这个过程充满了风险：

  * **忘记 `delete`**：导致**内存泄漏 (Memory Leak)**。程序占用的内存越来越多，最终可能耗尽资源而崩溃。
  * **重复 `delete`**：对同一块内存释放两次，会导致未定义行为，通常是程序崩溃。
  * **悬空指针 (Dangling Pointer)**：指针指向的内存已经被释放，但指针本身没有被置空，后续对该指针的访问会导致灾难性后果。

**核心问题**：手动管理内存，开发者需要精确地知道谁（哪个指针）拥有这块内存，以及何时应该释放它。在复杂的程序中（例如，函数有多个返回路径、发生异常等），这变得极其困难。

**智能指针的解决方案**：将内存（或任何资源）的所有权封装在一个对象中。当这个对象离开作用域时，它的析构函数会自动被调用，并在析构函数中释放所管理的资源。这就是自动化内存管理。

---

## 2. RAII机制：智能指针的基石

**RAII (Resource Acquisition Is Initialization)**，翻译为“资源获取即初始化”，是C++语言的核心思想之一。

  * **核心理念**：将资源的生命周期与一个对象的生命周期绑定。
  * **实现方式**：
      * 在对象的**构造函数**中获取资源（例如，`new` 分配内存）。
      * 在对象的**析构函数**中释放资源（例如，`delete` 释放内存）。
  * **优势**：C++保证了当一个栈上对象离开其作用域时，其析构函数一定会被调用（即使发生了异常）。这确保了资源总能被正确释放。

**所有的智能指针都是RAII机制的完美实践。**

-----

## 3. `std::unique_ptr`：独占所有权的指针

`std::unique_ptr` 是最简单、最高效的智能指针。正如其名，它对所管理的对象拥有**独占所有权**。

### 概念与特性

  * **独占性**：在任何时刻，只有一个 `unique_ptr` 可以指向一个给定的对象。
  * **轻量级**：它的开销和原始指针几乎完全一样，没有额外的性能负担。
  * **不可复制**：你不能复制一个 `unique_ptr`，因为它会破坏所有权的唯一性。
    ```cpp
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    // std::unique_ptr<int> ptr2 = ptr1; // 编译错误！
    ```
  * **可以移动**：虽然不能复制，但可以通过**移动语义 (Move Semantics)** 将所有权从一个 `unique_ptr` **转移**给另一个。
    ```cpp
    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    std::unique_ptr<int> ptr2 = std::move(ptr1); // 正确，ptr1现在为空，ptr2拥有所有权
    ```

### 具体用法

#### 创建与初始化

1.  **首选方式：`std::make_unique<T>(...)` (C++14)**
    这是最安全、最高效、最简洁的方式。它将对象的创建和`unique_ptr`的构造封装在一步操作中。

    ```cpp
    #include <memory>
    #include <string>

    struct Widget {
        Widget(int id, std::string name) { /*...*/ }
    };

    // 创建指向单个对象的 unique_ptr
    auto pWidget = std::make_unique<Widget>(1, "MyWidget");

    // 创建指向动态数组的 unique_ptr
    // 注意：要使用 T[] 的形式
    auto pArray = std::make_unique<int[]>(10); // 创建一个包含10个整数的数组
    pArray[0] = 100;
    ```

    **为什么 `make_unique` 更好？**

      * **异常安全**：考虑这个表达式 `process(std::unique_ptr<Widget>(new Widget(1, "w")), compute_priority())`。C++标准不保证函数参数的求值顺序。可能发生的情况是：1. `new Widget` 执行成功；2. `compute_priority()` 执行并抛出异常；3. `std::unique_ptr` 的构造函数还没来得及执行。结果是 `new` 出来的内存永远泄漏了。而 `make_unique` 将内存分配和指针构造合并，不存在这个问题。
      * **简洁性**：代码更短，无需重复写类型名，也避免了使用 `new` 关键字。

2.  **次选方式：使用 `new` 初始化 (C++11)**
    在C++11中没有 `make_unique`，或者在某些特定场景（如需要自定义删除器）下，需要直接使用 `new`。

    ```cpp
    std::unique_ptr<Widget> pWidget(new Widget(1, "MyWidget"));
    ```

    **注意**：不要这样做 `std::unique_ptr<Widget> p = new Widget(...)`，这是错误的，`unique_ptr` 的构造函数是 `explicit` 的，禁止裸指针的隐式转换。

#### 核心用法与操作

1.  **访问成员**：和裸指针一样，使用 `->` 和 `*`。

    ```cpp
    pWidget->some_method();
    (*pWidget).some_property = 42;
    ```

    对于数组类型，使用 `[]` 操作符。

    ```cpp
    pArray[5] = 50;
    ```

2.  **所有权转移 (Move Semantics)**
    `unique_ptr` 的精髓在于其所有权的唯一性，它删除了拷贝构造函数和拷贝赋值操作符，但提供了移动构造函数和移动赋值操作符。

      * **函数返回值**：这是最常见的转移方式，编译器会自动处理移动。

        ```cpp
        std::unique_ptr<Widget> createWidget() {
            return std::make_unique<Widget>(2, "AnotherWidget"); // 自动移动
        }
        auto p = createWidget(); // p 获得了所有权
        ```

      * **函数参数传递**：需要显式使用 `std::move` 来表明所有权的转移。

        ```cpp
        void consumeWidget(std::unique_ptr<Widget> consumer_ptr) {
            // consumer_ptr 在此函数内拥有所有权
            // 函数结束时，Widget 对象被销毁
        }
        consumeWidget(std::move(p)); // p 将所有权转移给 consumer_ptr
        // 之后，p 变为了 nullptr
        ```

      * **在变量间转移**：

        ```cpp
        auto p1 = std::make_unique<int>(10);
        auto p2 = std::move(p1); // p2 获得所有权, p1 变为空
        ```

3.  **释放与重置**

      * **`reset()`**：释放当前管理的对象，并可以选择性地接管一个新对象。

        ```cpp
        p2.reset(); // 释放 p2 管理的整数，p2 变为空
        p1.reset(new int(20)); // p1 接管一个新的整数
        ```

      * **`release()`**：**放弃**所有权，并返回裸指针。**注意**：调用 `release` 后，调用者有责任手动 `delete` 返回的裸指针。这通常用于与一些只接受裸指针的旧API交互。

        ```cpp
        int* raw_ptr = p1.release(); // p1 变为空，不再管理对象
        // ... 使用 raw_ptr ...
        delete raw_ptr; // 你必须手动释放！
        ```

4.  **获取裸指针**

      * **`get()`**：返回指向被管理对象的裸指针，但**不放弃所有权**。用于需要传递裸指针但不想转移所有权的场景。

        ```cpp
        void observeWidget(Widget* w) { /* ... */ }
        observeWidget(pWidget.get());
        ```

#### 自定义删除器

`unique_ptr` 可以管理任何需要“配对”操作的资源，不仅仅是 `new/delete`。例如文件句柄 `fopen/fclose`。

删除器的类型是 `unique_ptr` 类型的一部分，这使得它非常高效（通常不会增加 `unique_ptr` 的大小，如果删除器是无状态的lambda或函数对象）。

```cpp
#include <cstdio>

// 删除器函数对象
struct FileCloser {
    void operator()(FILE* fp) const {
        if (fp) {
            std::cout << "Closing file.\n";
            fclose(fp);
        }
    }
};

// 使用函数对象作为删除器
std::unique_ptr<FILE, FileCloser> file_ptr(fopen("test.txt", "w"));

// 使用 lambda 作为删除器
auto file_deleter = [](FILE* fp){
    if (fp) {
        std::cout << "Closing file via lambda.\n";
        fclose(fp);
    }
};
std::unique_ptr<FILE, decltype(file_deleter)> another_file_ptr(fopen("test2.txt", "w"), file_deleter);
```

---

## 4. `std::shared_ptr`：共享所有权的指针

`std::shared_ptr` 允许多个指针共同拥有同一个对象。

### 概念与特性

  * **共享所有权**：可以被自由地复制和赋值，多个 `shared_ptr` 可以指向同一个对象。
  * **引用计数 (Reference Counting)**：`shared_ptr` 内部维护一个“引用计数”，记录有多少个 `shared_ptr` 实例正指向同一个对象。
      * 每当一个新的 `shared_ptr` 指向该对象时（例如通过复制），引用计数加1。
      * 每当一个 `shared_ptr` 被销毁或指向其他对象时，引用计数减1。
      * 当引用计数变为0时，代表没有任何 `shared_ptr` 指向该对象，对象会被自动删除。
  * **控制块 (Control Block)**：引用计数等管理信息存储在一个单独的“控制块”中，这个控制块是在第一个 `shared_ptr` 创建时动态分配的。

### 具体用法

#### 创建与初始化

1.  **首选方式：`std::make_shared<T>(...)` (C++11)**
    绝对的最佳实践。

    ```cpp
    auto spWidget = std::make_shared<Widget>(3, "SharedWidget");
    ```

    **为什么 `make_shared` 更好？**

      * **性能**：它只执行**一次**堆内存分配。`shared_ptr` 需要一个“控制块”来存储引用计数和删除器等信息。`make_shared` 会一次性分配一块足够大的内存，同时容纳 `Widget` 对象和控制块。而 `std::shared_ptr<Widget>(new Widget(...))` 会导致**两次**堆分配：一次是 `new Widget`，另一次是 `shared_ptr` 内部为控制块分配内存。堆分配是昂贵的操作，一次分配能显著提升性能并减少内存碎片。
      * **异常安全**：理由同 `make_unique`。

2.  **次选方式：从 `new` 初始化**

    ```cpp
    std::shared_ptr<Widget> spWidget(new Widget(3, "SharedWidget"));
    ```

    **注意**：绝对不要用一个已经由其他智能指针（或裸指针）管理的指针来初始化一个新的`shared_ptr`！

    ```cpp
    Widget* raw = new Widget(4, "Bad");
    std::shared_ptr<Widget> sp1(raw);
    // std::shared_ptr<Widget> sp2(raw); // 灾难！sp1和sp2有不同的控制块
    // 当 sp1 和 sp2 析构时，它们都会尝试 delete raw，导致重复释放。
    ```

#### 核心用法与操作

1.  **复制与引用计数**
    `shared_ptr` 可以被自由地复制和赋值，这是它的核心特性。

    ```cpp
    auto sp1 = std::make_shared<int>(100);
    std::cout << "Use count: " << sp1.use_count() << std::endl; // 输出 1

    auto sp2 = sp1; // 拷贝构造，引用计数变为 2
    std::cout << "Use count: " << sp1.use_count() << std::endl; // 输出 2

    {
        auto sp3 = sp1; // 引用计数变为 3
        std::cout << "Use count: " << sp1.use_count() << std::endl; // 输出 3
    } // sp3 离开作用域，引用计数变回 2

    sp2.reset(); // sp2 不再指向对象，引用计数变回 1
    std::cout << "Use count: " << sp1.use_count() << std::endl; // 输出 1
    ```

2.  **从 `unique_ptr` 转换**
    `unique_ptr` 可以隐式地（通过移动）转换为 `shared_ptr`，因为这是权限的“放大”（从独占到共享），是安全的。

    ```cpp
    auto up = std::make_unique<int>(200);
    std::shared_ptr<int> sp = std::move(up); // up 所有权转移给 sp，up 变为空
    // std::shared_ptr<int> sp = up; // 编译错误，不能隐式拷贝
    ```

    反过来则不行，`shared_ptr` 无法安全地转换为 `unique_ptr`。

#### `enable_shared_from_this` 与 `shared_from_this`

**问题场景**：在一个类的成员函数内部，需要获取一个指向 `this` 对象的 `shared_ptr`，并传递给其他函数。

**错误示范**：`some_func(std::shared_ptr<MyClass>(this));` 这会创建新的控制块，导致重复释放。

**正确方案**：让类公开继承 `std::enable_shared_from_this<T>`。

```cpp
#include <iostream>
#include <memory>

class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    MyClass() { std::cout << "MyClass constructed\n"; }
    ~MyClass() { std::cout << "MyClass destructed\n"; }

    std::shared_ptr<MyClass> getShared() {
        return shared_from_this(); // 安全地获取 this 的 shared_ptr
    }
};

void processMyClass(std::shared_ptr<MyClass> ptr) {
    std::cout << "Processing. Use count: " << ptr.use_count() << std::endl;
}

int main() {
    std::shared_ptr<MyClass> sp1 = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> sp2 = sp1->getShared(); // sp2 和 sp1 共享所有权

    std::cout << "Main. Use count: " << sp1.use_count() << std::endl; // 输出 2
    processMyClass(sp2); // 引用计数会临时变为 3
    return 0;
}
```

**工作原理**：当你用 `make_shared` 创建 `MyClass` 对象时，`make_shared` 会检测到它继承自 `enable_shared_from_this`，并在控制块中额外存储一个 `weak_ptr` 指向该对象。调用 `shared_from_this()` 时，它会用这个内部的 `weak_ptr` 来 `lock()`，从而安全地创建一个新的、共享所有权的 `shared_ptr`。
**注意**：必须确保在调用 `shared_from_this()` 之前，已经有一个 `shared_ptr` 拥有该对象。


---

## 5. `std::weak_ptr`：`shared_ptr`的“观察者”


`weak_ptr` 本身不拥有资源，它像一个“旁观者”，监视一个由 `shared_ptr` 管理的对象。它的存在不影响对象的生命周期。

### 核心用途：打破循环引用

想象一个双向链表或观察者模式，对象 A 和 B 互相持有对方的 `shared_ptr`。

```cpp
struct B; // 前向声明
struct A {
    std::shared_ptr<B> b_ptr;
    ~A() { std::cout << "A destructed\n"; }
};
struct B {
    std::shared_ptr<A> a_ptr; // 这里导致循环引用
    ~B() { std::cout << "B destructed\n"; }
};

void test_cycle() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->b_ptr = b;
    b->a_ptr = a;
    // test_cycle 结束时，a 和 b 的 use_count 都是 2
    // a 的引用计数被 main 和 b->a_ptr 持有
    // b 的引用计数被 main 和 a->b_ptr 持有
    // 两者都无法降到 0，内存泄漏！
}
```

**解决方案**：将其中一方的强引用改为弱引用。通常是“子”指向“父”，或“被观察者”指向“观察者”。

```cpp
struct B_fixed;
struct A_fixed {
    std::shared_ptr<B_fixed> b_ptr;
    ~A_fixed() { std::cout << "A_fixed destructed\n"; }
};
struct B_fixed {
    std::weak_ptr<A_fixed> a_ptr; // 使用 weak_ptr
    ~B_fixed() { std::cout << "B_fixed destructed\n"; }
};
// 现在 test_cycle 结束时，a 的引用计数可以正常降为0，从而被析构。
// a 析构时，其成员 b_ptr 被析构，b 的引用计数也降为0，b 被析构。问题解决。
```

#### 用法：检查与访问

`weak_ptr` 不能直接访问对象，需要先“升级”为 `shared_ptr`。

1.  **`expired()`**：检查所观察的对象是否已被销毁。

    ```cpp
    std::weak_ptr<MyClass> wp = sp1;
    if (wp.expired()) {
        std::cout << "Object has been destroyed.\n";
    }
    ```

2.  **`lock()`**：尝试获取一个有效的 `shared_ptr`。

      * 如果对象存在，返回一个指向它的 `shared_ptr`，引用计数加1。
      * 如果对象已销毁，返回一个空的 `shared_ptr`。

    这是访问 `weak_ptr` 所指对象的**唯一正确方式**。

    ```cpp
    if (std::shared_ptr<MyClass> locked_sp = wp.lock()) {
        // 在这个 if 作用域内，我们得到了一个有效的 shared_ptr
        // 可以安全地访问对象
        locked_sp->some_method();
        std::cout << "Successfully locked. Use count: " << locked_sp.use_count() << std::endl;
    } else {
        std::cout << "Failed to lock. Object is gone.\n";
    }
    ```

* **为什么需要 `lock()`？** 
    * 因为在多线程环境中，`expired()` 检查和访问之间可能存在竞态条件。可能你刚检查完 `!expired()`，另一个线程就释放了最后一个 `shared_ptr`，对象被销毁。而 `lock()` 是一个原子操作，保证了检查和获取 `shared_ptr` 的过程是安全的。
---

## 6. 横向对比

| 特性 | `std::unique_ptr` | `std::shared_ptr` | `std::weak_ptr` |
| :--- | :--- | :--- | :--- |
| **所有权** | 独占 (Exclusive) | 共享 (Shared) | 非拥有 (Non-owning) |
| **引用计数** | 无 | 有 (原子操作) | 无 (观察shared\_ptr的) |
| **性能开销** | 极低 (等同于裸指针) | 较高 (大小、控制块、原子操作) | 较高 (需要访问控制块) |
| **可否复制** | 否 (只能移动) | 是 | 是 |
| **核心用途** | 对象所有权的唯一管理者 | 多处代码共享对象所有权 | 打破 `shared_ptr` 的循环引用 |
| **创建方式** | `std::make_unique` | `std::make_shared` | 从 `shared_ptr` 构造 |

**选择策略**：

1.  **默认使用 `std::unique_ptr`**。这是最安全、最高效的选择。
2.  当你确定需要共享对象的所有权时（例如，一个对象被多个数据结构同时引用），才使用 `std::shared_ptr`。
3.  当你发现 `shared_ptr` 之间可能形成循环引用时，将其中一个引用关系（通常是“子”指向“父”）改为 `std::weak_ptr`。

---

## 7. 快问快答

1.  **`std::make_shared` (或 `make_unique`) 相对于 `new` 的优势是什么？**

      * **异常安全**：考虑 `foo(std::shared_ptr<T>(new T()), some_func())`，如果 `some_func()` 抛出异常，`new T()` 分配的内存可能会泄漏。而 `std::make_shared<T>()` 能保证资源被正确管理。
      * **性能** (`make_shared`): `make_shared` 只进行一次内存分配（为对象和控制块），而 `std::shared_ptr<T>(new T())` 需要两次分配，一次为 `T`，一次为控制块。一次分配通常更快且能减少内存碎片。

2.  **`shared_ptr` 是线程安全的吗？**

      * **控制块是线程安全的**：多个线程可以同时复制、销毁指向同一个对象的 `shared_ptr` 实例，引用计数的增减是原子的，不会导致数据竞争。
      * **所管理的对象不是线程安全的**：如果多个线程通过各自的 `shared_ptr` 实例去修改对象本身的数据成员，你仍然需要自己加锁（如 `std::mutex`）来保护对象。

3.  **如何将 `this` 指针安全地传递给一个接受 `shared_ptr` 的函数？**

      * **错误做法**：`some_func(std::shared_ptr<MyClass>(this))`。这会创建一个新的、独立的 `shared_ptr`，它和外部已存在的 `shared_ptr` 拥有不同的控制块。当其中一个 `shared_ptr` 销毁对象后，另一个就会成为野指针，导致双重释放。
      * **正确做法**：让你的类继承自 `std::enable_shared_from_this<YourClass>`，然后调用 `shared_from_this()` 方法。这个方法会返回一个与已存在的 `shared_ptr` 共享所有权的新的 `shared_ptr`。

---

