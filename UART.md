
## 一、UART 学习笔记

---

### 1. UART 简介

* UART（Universal Asynchronous Receiver/Transmitter）：一种异步串行通信协议，常用于 MCU 与外设、PC、传感器、模块等的点对点通信。
* 特点：

  * 异步通信，无需共享时钟。
  * 典型用于一对一通信（TX→RX）。
  * 简单易用，应用广泛。

---

### 2. UART 基本通信机制

* **数据帧结构：**

  ```
  | 起始位 | 数据位 | 校验位（可选） | 停止位 |
  ```

  * 起始位（Start Bit）：1 位，低电平（0）
  * 数据位（Data Bits）：一般 8 位，LSB 先传
  * 校验位（Parity Bit）：可选，偶/奇校验，用于检测1位错误
  * 停止位（Stop Bit）：1\~2 位，高电平（1）

* **波特率（Baud Rate）：**

  * 表示每秒传输的比特数（如 9600、115200）。
  * 双方须配置一致。

* **物理连接：**

  * TX（发送），RX（接收），GND（三线制）

---

### 3. UART 通信流程

1. 空闲时线路为高电平（1）。
2. 起始位拉低（0）→ 通知接收方数据开始。
3. 依次采样数据位（LSB 优先），可选采样校验位。
4. 采样停止位（高电平），如不为高电平判为帧错误。
5. 每一位采样时间依波特率决定，接收方通常用 16 倍采样率提高可靠性。

---

### 4. 软件层参数与配置

* 波特率：9600/115200/921600 等
* 数据位：8（常见）
* 停止位：1 或 2
* 校验位：无/奇/偶
* 流控：无/RTS-CTS（硬件流控）
* 接收方式：轮询/中断/DMA

---

### 5. 软件实现与驱动模式

* 轮询：简单但易丢数据，占用 CPU。
* 中断：接收/发送触发中断，推荐，响应及时。
* DMA：适合大量高速数据，CPU 负载低，配置复杂。

---

### 6. 常见问题与排查

| 现象  | 可能原因            |
| --- | --------------- |
| 乱码  | 波特率/数据位配置不一致    |
| 丢包  | 缓冲区溢出、中断响应不及时   |
| 无数据 | TX/RX 未正确连接、未接地 |
| 帧错误 | 波特率误差过大、采样偏移    |
| 校验错 | 奇偶设置不一致、线噪声干扰   |

---

### 7. UART vs SPI/I2C 简要对比

| 协议   | 时钟 | 多主 | 引脚 | 速率 | 应用    |
| ---- | -- | -- | -- | -- | ----- |
| UART | 无  | 否  | 2  | 中  | 调试、外设 |
| I2C  | 有  | 是  | 2  | 低  | 传感器等  |
| SPI  | 有  | 是  | 4+ | 高  | 存储等   |

---

### 8. 常见嵌入式场景

* 串口调试输出（如重定向 printf）
* 蓝牙、GPS、GPRS、LoRa 等模块通信
* Bootloader/工厂测试/OTA 升级
* 跨板通信与产测协议

---

## 二、UART 高频面试问题

---

### 基础问题

1. UART 和 SPI/I2C 的核心区别是什么？为什么 UART 不适合多主多从？
2. 解释 UART 一帧的组成部分，各字段的作用是什么？
3. 波特率不一致时，为什么会出现乱码？原理是什么？
4. UART 通常采用哪种方式来同步接收端的采样节奏？
5. UART 为何要用低电平作为起始位？

---

### 软件驱动相关问题

6. 你在项目中如何配置 UART 驱动？主要设置哪些参数？
7. UART 驱动中断处理函数里你会做哪些工作？如何避免阻塞？
8. 如果收发的数据量非常大，如何设计软件结构提高 UART 吞吐率？
9. UART DMA 收发过程中，如何避免数据覆盖和同步问题？
10. 如何实现一个支持多波特率配置的 UART 接口初始化函数？

---

### 进阶加分问题

11. 解释 UART 波特率误差容忍范围的推导过程。
12. UART 数据帧在采样偏移条件下最多可以传输多少位？
13. 如果必须实现多主通信（如主控同时管理多个从设备），你会如何改造 UART 协议？
14. 如何在裸机系统中基于 UART 实现 printf？底层原理是什么？
15. 如何使用 DMA + FIFO 设计一个高可靠性的 UART 接收系统？

---

## 三、参考答案



---

### 1. **UART 和 SPI/I2C 的核心区别是什么？为什么 UART 不适合多主多从？**

|   特性   |    UART     |       I2C        |      SPI      |
| -------- | ----------- | ---------------- | ------------- |
| 通信方式 | 异步，点对点 | 同步，总线多主多从 | 同步，主从     |
| 时钟线   | 无          | 共享 SCL          | 主控提供 SCLK  |
| 多主支持 | 不支持       | 有仲裁机制         | 支持多个从设备 |

**为什么 UART 不支持多主多从：**

* UART 没有地址机制（不像 I2C 有器件地址）
* 物理线路（TX）是主动驱动，多设备同时驱动会造成总线冲突
* 没有仲裁机制，无法协调多个设备的访问时机

---

### 2. **解释 UART 一帧的组成部分，各字段的作用是什么？**

一个典型的 UART 帧结构如下：

```
| Start (1bit) | Data (5~9bit) | Parity (0/1bit) | Stop (1~2bit) |
```

* **Start Bit（起始位）**：拉低线路，告诉接收器“我要开始发数据了”
* **Data Bits（数据位）**：实际传输的有效数据，通常为 8 位，LSB First
* **Parity Bit（校验位）**：可选，用于检测单个 bit 错误
* **Stop Bit（停止位）**：表示一帧结束，线路返回高电平（空闲）

---

### 3. **波特率不一致时，为什么会出现乱码？原理是什么？**

UART 是异步通信，双方没有共享时钟，靠 **起始位检测 + 自身时钟计数**对齐采样。

* 若接收端和发送端的波特率不一致，接收端采样点逐渐偏离数据中心
* 偏差积累 → 采样位错误 → 解码错误 → 出现乱码
* 通常波特率误差容忍度在 ±2%\~±5% 之间，超过就可能频繁错误

---

### 4. **UART 通常采用哪种方式来同步接收端的采样节奏？**

使用 **起始位的跳变（高→低）检测**作为参考点，在本地时钟基础上启动采样定时器。

* 一旦检测到起始位（0），就开始以 16×波特率进行采样
* 在每个位的**中间位置**采样（如第8个采样点）以避开边沿抖动
* 通过高倍采样和中间点取值实现“软同步”

---

### 5. **UART 为何要用低电平作为起始位？**

* 默认空闲状态为高电平（逻辑 1）
* 当线路从高电平 → 低电平跳变，接收端可明确检测起始
* 逻辑上通过“明显的状态突变”标志帧开始

这是一种“易检测、抗噪声”的设计。

---


### 6. **你在项目中如何配置 UART 驱动？主要设置哪些参数？**

常见参数有：

* 波特率：9600 / 115200（取决于设备要求）
* 数据位数：8 位
* 停止位数：1 或 2 位（长线通信用2位更稳）
* 校验位：None（默认）、Even、Odd
* 硬件流控：无（或 RTS/CTS）
* 接收方式：轮询 / 中断 / DMA（数据量大时）

通常在初始化时调用 HAL 或驱动配置函数，如 STM32 的 `HAL_UART_Init()`，或者 Linux 下的 `termios` 配置串口参数。

---

### 7. **UART 驱动中断处理函数里你会做哪些工作？如何避免阻塞？**

中断处理流程：

1. 判断是否为接收中断（RXNE）、发送中断（TXE）或错误中断
2. RXNE 中断中读取接收寄存器数据 → 放入环形缓冲区
3. TXE 中断中取出发送缓冲区数据 → 写入发送寄存器
4. 清除中断标志位

**避免阻塞：**

* 中断函数要足够短小，不做复杂处理
* 接收数据后放入缓冲区，交由主循环或其他线程处理
* 或结合 DMA 提高吞吐率

---

### 8. **如果收发的数据量非常大，如何设计软件结构提高 UART 吞吐率？**

* 使用 **DMA** 接收，避免频繁中断
* 使用 **环形缓冲区 FIFO** 存储接收/发送数据
* 设置 **接收空闲中断**（如 STM32 的 IDLE Line 中断）配合 DMA 自动识别帧尾
* 定期检查 DMA 写入指针，做断帧处理
* 使用 **RTOS 的队列 / 消息机制** 解耦业务与底层驱动

---

### 9. **UART DMA 收发过程中，如何避免数据覆盖和同步问题？**

* 配置 DMA 成环形模式 + 环形缓冲区
* 使用 UART 的 **空闲中断（IDLE）** 检测帧尾
* 在中断中记录 DMA 当前位置与上一次位置，识别新数据长度
* 通过双缓冲结构处理临界区问题（生产者/消费者模式）

---

### 10. **如何实现一个支持多波特率配置的 UART 接口初始化函数？**

关键思路：

* 提供一个通用 UART 初始化函数，带参数：

```c
void uart_init(uint32_t baudrate, uint8_t parity, uint8_t stop_bits)
```

* 内部根据参数填充结构体（如 `USART_InitTypeDef`）
* 自动计算串口分频寄存器值
* 若支持自动波特率检测（Autobaud），则先接收0x55，再自动计算位宽、设置波特率

---


### 11. **解释 UART 波特率误差容忍范围的推导过程。**

每位最大采样偏移不能超过 `±0.5个 bit`，否则可能采到相邻位。

设：

* 帧长 n 位（例如 10）
* 波特率误差为 `Δ = |sender - receiver| / sender`

采样漂移总量：`Δ × n`

若：

```
Δ × n ≤ 0.5
→ Δ ≤ 1 / (2n)
```

所以：

* n=10 ⇒ Δ ≤ 5%
* 实际推荐：各自不超过 ±1.5%\~2%

---

### 12. **UART 数据帧在采样偏移条件下最多可以传输多少位？**

* 假设每位采样偏移 1 个采样点（16x 采样）
* 每位中心是第8点，最大偏移容忍是 ±8

因此最多可传输 8 位数据：

```
8 × 1 = 8 个偏移采样点，不超过 8
```

---

### 13. **如果必须实现多主通信（如主控同时管理多个从设备），你会如何改造 UART 协议？**

* 使用 **应用层协议**在数据中加入地址字段
* 每个设备判断地址是否为自己 → 决定是否响应
* 主控采用 **轮询策略**避免冲突
* 或使用额外 **使能引脚** 控制哪个设备能发数据（比如用 GPIO 控制 TX 线）

但这只是“伪多主”，UART 本质还是点对点协议。

---

### 14. **如何在裸机系统中基于 UART 实现 printf？底层原理是什么？**

* 将 `printf()` 重定向到底层串口发送函数
* 修改 `fputc()` 或 `_write()`，将字符逐个发送到 UART 寄存器
* 底层发送函数等待 TXE（发送寄存器空）标志再写入数据

```c
int fputc(int ch, FILE *f) {
    while (!(USARTx->SR & USART_SR_TXE));
    USARTx->DR = (ch & 0xFF);
    return ch;
}
```

---

### 15. **如何使用 DMA + FIFO 设计一个高可靠性的 UART 接收系统？**

* 启用 DMA 环形缓冲区接收（如 512字节）
* 配置 UART IDLE 中断，作为帧尾检测机制
* 在中断中读取 DMA 当前写指针与上次位置
* 把数据放入 **用户级 FIFO 缓冲区**
* 使用信号量或消息通知上层任务处理数据

这样可以做到：

* **高速接收**（DMA）
* **边界检测**（IDLE）
* **数据缓存**（FIFO）
* **解耦数据处理与中断**（多任务）

---

## END

